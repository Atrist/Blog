---
title: 3的幂
date: 2020-12-09
tags: 
  - leetcode
summary: 刷算法,向前进
author: Atrist
---

## 参考资料

1. [leetcode 初级算法](https://leetcode-cn.com/leetbook/detail/top-interview-questions-easy/)
2. [3的幂](https://leetcode-cn.com/problems/power-of-three/description/)

## 3的幂
给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 `true` ；否则，返回 `false` 。

整数 `n` 是 `3` 的幂次方需满足：存在整数 `x` 使得 $n == 3^x$

## 解决方法：
在本文中，我们将探讨加速简单计算的方法，以及为什么在实践中有用。

## 方法一：循环迭代
找出数字 `n` 是否是数字 `b` 的幂的一个简单方法是，`n%3` 只要余数为 `0`，就一直将 `n` 除以 `b`。

$$\begin{aligned} n &= b^x \ n &= b \times b \times \ldots \times b \end{aligned}$$

因此，应该可以将 `n` 除以 `b` x 次，每次都有 0 的余数，最终结果是 1。

### 代码
```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function(n) {
    if(n<1) return false
    while(n%3 === 0) n /=3
    return  n ==1
};
```
注意我们需要一个警卫来检查那个 `n！=0`，否则 while 循环将永远不会结束。对于负数，该算法没有意义，因此我们也将包括该保护。

### 复杂度分析

- 时间复杂度：$O(\log_b(n))$，在我们的例子中是 $O(\log n)$。除数是用对数表示的。
- 空间复杂度：O(1)，没有使用额外的空间。



## 方法二：基准转换
在基数 10 中，10 的所有幂都从数字 1 开始，然后只跟 0（例如10、100、1000）。其他基地及其各自的权力也是如此。例如，在基数 2 中，$10 _2$、$100 _2$和 $1000 _2$分别表示为 $2_{10}$, $4_{10}$和 $8_{10}$。因此，如果我们把我们的数转换成基3，并且表示形式是 100…0，那么这个数就是3的幂。

### 证明 ：
给定以 3 为底的数字表示为数组 `s`，第 0 位开始为有效数字，从 3 为底转换为 10 为底的公式为：

$$\sum_{i=0}^{len(s) - 1} s[i] * 3^{i}$$

因此，只有一个数字 1，其余的都是 0，这意味着这个数字是 3 的幂。

### 实现：
- 我们所要做的就是将数字转换为以3为底的基数 ，并检查它是否为前导1，后跟所有 0。

### 代码
```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function(n) {
    return /^10{0,}$/.test(n.toString(3))
};
```

### 复杂度分析

- 时间复杂度：$O(\log_3n)$
  
  - 假设：
    - `Integer.toString()` - 基转换通常是作为一个重复的除法来实现的。复杂性应该类似于我们的方法 $1:O（\ log_3n）$的复杂性。
    - `String.matches()` - 方法迭代整个字符串。`n` 以 3 为基数表示的位数是$O（\log_3n）$。
- 空间复杂度：$O(\log_3n)$。我们使用两个附加变量。
  - 以 3 为基数表示数字的字符串（大小为 $\log_3n$
  - 正则表达式的字符串（常量大小）

## 方法三：运算法
我们可以用下面的数学公式

$$n = 3^i \ i = \ log_3(n) \ i = \frac{\ log_b(n)}{\ log_b(3)}$$

若 `n` 是 `3` 的幂则 `i` 是整数。在 Java 中，我们通过取小数部分（利用 `% 1`）来检查数字是否是整数，并检查它是否是 `0`。

### 代码
```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function(n) {
    return  (Math.log10(n) / Math.log10(3)) % 1 == 0;
};
```

### 复杂度分析

- 时间复杂度：Unknown。这里主要消耗时间的运算是 Math.log，它限制了我们算法的时间复杂性。实现依赖于我们使用的语言和编译器 。
- 空间复杂度： O(1)，我们没有使用任何额外的内存。

## 方法四：整数限制
一个重要的信息可以从函数名中推导出来。

我们可以看出 n 的类型是 int。在 Java 中说明了该变量是四个字节，他的最大值为 2147483647。有三种方法可以计算出该最大值。

1. [Google](http://stackoverflow.com/questions/15004944/max-value-of-integer)
2. System.out.println(Integer.MAX_VALUE);
3. $MaxInt = \frac{ 2^{32} }{2} - 1$, 因为我们使用 32 位来表示数字，所以范围的一半用于负数，0 是正数的一部分。

知道了 n 的限制，我们现在可以推断出 n 的最大值，也就是 3 的幂，是 **1162261467**。我们计算如下：

$$3^{\lfloor{}\log_3{MaxInt}\rfloor{}} = 3^{\lfloor{}19.56\rfloor{}} = 3^{19} = 1162261467$$

因此，我们应该返回 `true` 的 n 的可能值是 $3^0$，$3^1$ …$3 ^ {19}$
 。因为 3 是质数，所以 $3^{19}$的除数只有 $3^0$，$3^13$…$3 ^{19}$ 因此我们只需要将 $3^{19}$除以 n。若余数为 0 意味着 n 是 $3^{19}$的除数，因此是 3 的幂。
### 代码
```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function(n) {
    return   n > 0 && 1162261467 % n == 0;
};
```
### 复杂度分析

- 时间复杂度：O(1)。我们只做了一次操作。
- 空间复杂度： O(1)，没有使用额外空间。

### 结论 :
像这样的简单优化似乎可以忽略不计，但历史上，当计算能力成为一个问题时，它允许某些计算机程序（如Quake 3）成为可能。