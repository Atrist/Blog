---
title: 实现 strStr()
date: 2020-11-16
tags: 
  - leetcode
summary: 刷算法,向前进
author: Atrist
---

## 参考资料

1. [leetcode 初级算法](https://leetcode-cn.com/leetbook/detail/top-interview-questions-easy/)
2. [实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/description/)


## 实现 strStr() 函数。

给定一个 `haystack` 字符串和一个 `needle` 字符串，在 `haystack` 字符串中找出 `needle` 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  `-1`。

### 示例 1:
```bash
输入: haystack = "hello", needle = "ll"
输出: 2
```
### 示例 2:
```bash
输入: haystack = "aaaaa", needle = "bba"
输出: -1
```
### 说明:

当 `needle` 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 `needle` 是空字符串时我们应当返回 `0` 


## 概述
这道题是要在 `haystack` 字符串中找到 `needle` 字符串。下面会给出的三种解法，这三种解法都基于滑动窗口。

子串逐一比较的解法最简单，将长度为 L 的滑动窗口沿着 hay`stack 字符串逐步移动，并将窗口内的子串与 needle 字符串相比较，时间复杂度为 $O((N−L)L)$

显示上面这个方法是可以优化的。双指针方法虽然也是线性时间复杂度，不过它可以避免比较所有的子串，因此最优情况下的时间复杂度为 $O(N)$，但最坏情况下的时间复杂度依然为 $O((N - L)L)$。

有 $O(N)$ 复杂度的解法嘛？答案是有的，有两种方法可以实现：

- Rabin-Karp，通过哈希算法实现常数时间窗口内字符串比较。
- 比特位操作，通过比特掩码来实现常数时间窗口内字符串比较。


## 方法一：子串逐一比较 - 线性时间复杂度
最直接的方法 - 沿着字符换逐步移动滑动窗口，将窗口内的子串与 needle 字符串比较。

![](./images/substrings.png)


### 代码
```js
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
    let subLength = needle.length;
    if(subLength === 0 ) return 0;
    for(let i = 0;i<=haystack.length - subLength; i++){
        if(needle === haystack.substr(i,subLength)){
            return  i;
        }
    }
    return -1;

};
```


### 复杂度分析

- 时间复杂度：$O((N - L)$，其中 N 为 haystack 字符串的长度，L 为 needle 字符串的长度。内循环中比较字符串的复杂度为 L，总共需要比较 (N - L) 次。
- 空间复杂度：$O(1)$。


## 方法二：双指针 - 线性时间复杂度
上一个方法的缺陷是会将 `haystack` 所有长度为 L 的子串都与 `needle` 字符串比较，实际上是不需要这么做的。

只有子串的第一个字符跟 `needle` 字符串第一个字符相同的时候才需要比较。
### 代码
```js
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
    let subLength = needle.length;
    if(subLength === 0 ) return 0;
    for(let i = 0;i<=haystack.length - subLength; i++){
        if(haystack[i] === needle[0]) {
            if(needle === haystack.substr(i,subLength)){
            return  i;
        }
      }
    }
    return -1;
};
```

### 复杂度分析
- 时间复杂度：最坏时间复杂度为 $O((N - L)L)$，最优时间复杂度为 $O(N)$。
- 空间复杂度：$O(1)$。

## 方法三： Rabin Karp - 常数复杂度
有一种最坏时间复杂度也为 $O(N)$ 的算法。思路是这样的，先生成窗口内子串的哈希码，然后再跟 `needle` 字符串的哈希码做比较。

这个思路有一个问题需要解决，如何在常数时间生成子串的哈希码？


### 滚动哈希：常数时间生成哈希码
生成一个长度为 L 数组的哈希码，需要 $O(L)$ 时间。

>如何在常数时间生成滑动窗口数组的哈希码？利用滑动窗口的特性，每次滑动都有一个元素进，一个出。