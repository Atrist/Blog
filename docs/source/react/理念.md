## React的理念
>我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。

快速响应的瓶颈
- cpu 瓶颈
- IO 瓶颈

###  关于 cpu 瓶颈:

在浏览器每一帧的时间中，预留一些时间给JS线程，React利用这部分时间更新组件（可以看到，在[源码](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L119) 中，预留的初始时间是5ms）。

当预留的时间不够用时，`React` 将线程控制权交还给浏览器使其有时间渲染UI，React则等待下一帧时间到来继续被中断的工作。

>这种将长任务分拆到每一帧中，像蚂蚁搬家一样一次执行一小段任务的操作，被称为时间切片（time slice）

解决 CPU 瓶颈的关键是实现 `时间切片`，而时间切片的关键是：将**同步的更新**变为**可中断的异步更新**

### IO 瓶颈
`网络延迟` 是前端开发者无法解决的。如何在网络延迟客观存在的情况下，减少用户对网络延迟的感知？

React给出的答案是 [将人机交互研究的结果整合到真实的 UI 中](https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html#putting-research-into-production)。


关键的一个窍门在于，在本页面停留**短暂的时间**，用于数据的请求，数据回来之后，在跳转到下一个页面。

当“这一小段时间”足够短时，用户是无感知的。如果请求时间超过一个范围，再显示`loading`的效果。


### 总结
这里解决IO和CPU瓶颈问题，落在实处上就是将**同步更新**变成**可中断的异步更新**


## React v15 架构
两层:
- Reconciler（协调器）—— 负责找出变化的组件
- Renderer（渲染器）—— 负责将变化的组件渲染到页面上

### Reconciler
每当有更新发生时，Reconciler会做如下工作：
- 调用函数组件、或class组件的render方法，将返回的JSX转化为虚拟DOM
- 将虚拟DOM和上次更新时的虚拟DOM对比
- 通过对比找出本次更新中变化的虚拟DOM
- 通知Renderer将变化的虚拟DOM渲染到页面上

### Renderer（渲染器）
由于React支持跨平台，所以不同平台有不同的 Renderer。我们前端最熟悉的是负责在浏览器环境渲染的Renderer —— [ReactDOM](https://www.npmjs.com/package/react-dom) 

### 架构的缺点
递归更新， 当组件列表更长，会导致更新时间超过16ms，导致用户交互卡顿。

## React v16 架构
三层：
- Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler
- Reconciler（协调器）—— 负责找出变化的组件
- Renderer（渲染器）—— 负责将变化的组件渲染到页面上

### Scheduler（调度器）
既然我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。

其实部分浏览器已经实现了这个API，这就是requestIdleCallback (opens new window)。但是由于以下因素，React放弃使用：

- 浏览器兼容性
- 触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的`requestIdleCallback`触发的频率会变得很低

基于以上原因，React实现了功能更完备的 `requestIdleCallbackc` polyfill，这就是**Scheduler**。除了在空闲时触发回调的功能外，Scheduler还提供了多种调度优先级供任务设置。

>[Scheduler](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/README.md) 是独立于React的库

### Reconciler（协调器）
在React15中Reconciler是递归处理虚拟DOM的。让我们看看[React16的Reconciler](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1673) 。

我们可以看见，更新工作从递归变成了可以中断的循环过程。每次循环都会调用`shouldYield`判断当前是否有剩余时间。
```js
/** @noinline */
function workLoopConcurrent() {
  // Perform work until Scheduler asks us to yield
  while (workInProgress !== null && !shouldYield()) {
    workInProgress = performUnitOfWork(workInProgress);
  }
}
```
那么React16是如何解决中断更新时DOM渲染不完全的问题呢？

在React16中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟DOM打上代表增/删/更新的标记，类似这样：
```js
export const Placement = /*             */ 0b0000000000010;
export const Update = /*                */ 0b0000000000100;
export const PlacementAndUpdate = /*    */ 0b0000000000110;
export const Deletion = /*              */ 0b0000000001000;
```
整个Scheduler与Reconciler的工作都在内存中进行。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。

### Renderer（渲染器）
Renderer根据Reconciler为虚拟DOM打的标记，同步执行对应的DOM操作。

![](https://react.iamkasong.com/img/process.png)

其中红框中的步骤随时可能由于以下原因被中断：

- 有其他更高优任务需要先更新
- 当前帧没有剩余时间

由于红框中的工作都在内存中进行，不会更新页面上的DOM，所以即使反复中断，用户也不会看见更新不完全的DOM（即上一节演示的情况）。

>实际上，由于Scheduler和Reconciler都是平台无关的，所以React为他们单独发了一个包[react-Reconciler](https://www.npmjs.com/package/react-reconciler)。你可以用这个包自己实现一个ReactDOM

### 参考资料
- [「英文 外网」Building a Custom React Renderer | React前经理Sophie Alpert](https://www.youtube.com/watch?v=CGpMlWVcHok&list=PLPxbbTqCLbGHPxZpw4xj_Wwg8-fdNxJRh&index=7)


## Fiber
### 什么代数效应
`代数效应`是`函数式编程`中的一个概念，用于将`副作用`从`函数`调用中分离。

### 代数效应在React中的应用
那么代数效应与React有什么关系呢？最明显的例子就是`Hooks`。

对于类似useState、useReducer、useRef这样的Hook，我们不需要关注FunctionComponent的state在Hook中是如何保存的，React会为我们处理。

我们只需要假设useState返回的是我们想要的state，并编写业务逻辑就行。
```js
function App() {
  const [num, updateNum] = useState(0);
  
  return (
    <button onClick={() => updateNum(num => num + 1)}>{num}</button>  
  )
}
```
如果这个例子还不够明显，可以看看官方的[Suspense Demo](https://codesandbox.io/s/frosty-hermann-bztrp?file=/src/index.js:152-160)

在`Demo`中`ProfileDetails`用于展示用户名称。而用户名称是**异步请求**的。

但是`Demo`中完全是同步的写法。
```js
function ProfileDetails() {
  const user = resource.user.read();
  return <h1>{user.name}</h1>;
}
```
### 代数效应与Generator
从React15到React16，协调器（Reconciler）重构的一大目的是：将老的同步更新的架构变为异步可中断更新。

异步可中断更新可以理解为：更新在执行过程中可能会被打断（浏览器时间分片用尽或有更高优任务插队），当可以继续执行时恢复之前执行的中间状态。

这就是代数效应中`try...handle`的作用。

其实，浏览器原生就支持类似的实现，这就是`Generator`。

但是Generator的一些缺陷使React团队放弃了他：

- 类似async，Generator也是传染性的，使用了Generator则上下文的其他函数也需要作出改变。这样心智负担比较重。

- Generator执行的中间状态是上下文关联的。

考虑如下例子：
```js
function* doWork(A, B, C) {
  var x = doExpensiveWorkA(A);
  yield;
  var y = x + doExpensiveWorkB(B);
  yield;
  var z = y + doExpensiveWorkC(C);
  return z;
}
```
每当浏览器有空闲时间都会依次执行其中一个doExpensiveWork，当时间用尽则会中断，当再次恢复时会从中断位置继续执行。

只考虑“单一优先级任务的中断与继续”情况下Generator可以很好的实现异步可中断更新。

但是当我们考虑“高优先级任务插队”的情况，如果此时已经完成doExpensiveWorkA与doExpensiveWorkB计算出x与y。

此时B组件接收到一个高优更新，由于Generator执行的中间状态是上下文关联的，所以计算y时无法复用之前已经计算出的x，需要重新计算。

如果通过全局变量保存之前执行的中间状态，又会引入新的复杂度。

>更详细的解释可以参考这个[issue](https://github.com/facebook/react/issues/7942#issuecomment-254987818)

基于这些原因，React没有采用Generator实现协调器。

### 代数效应与Fiber
`Fiber`并不是计算机术语中的新名词，他的中文翻译叫做纤程，与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。

在很多文章中将纤程理解为协程的一种实现。在JS中，协程的实现便是`Generator`。

所以，我们可以将`纤程`(Fiber)、`协程`(Generator)理解为代数效应思想在JS中的体现。

React Fiber可以理解为：

`React`内部实现的一套状态更新机制。支持任务不同**优先级**，可中断与恢复，并且恢复后可以复用之前的中间状态。

其中每个任务更新单元为`React Element`对应的`Fiber节点`。
### Fiber的起源
>最早的Fiber官方解释来源于[2016年React团队成员Acdlite的一篇介绍](https://github.com/acdlite/react-fiber-architecture)


在React15及以前，Reconciler采用递归的方式创建虚拟DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。

为了解决这个问题，`React16`将**递归的无法中断的更新**重构为**异步的可中断更新**，由于曾经用于递归的虚拟DOM数据结构已经无法满足需要。于是，全新的Fiber架构应运而生。

### Fiber的含义
Fiber包含三层含义：

1. 作为架构来说，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为`stack Reconciler`。React16的Reconciler基于Fiber节点实现，被称为`Fiber Reconciler`。
2. 作为静态的数据结构来说，每个Fiber节点对应一个`React element`，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。
3. 作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）。

### Fiber的结构
你可以从这里看到[Fiber节点的属性定义](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiber.new.js#L117)。虽然属性很多，但我们可以按三层含义将他们分类来看

```js
function FiberNode(
  tag: WorkTag,
  pendingProps: mixed,
  key: null | string,
  mode: TypeOfMode,
) {
  // 作为静态数据结构的属性
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null;

  // 用于连接其他Fiber节点形成Fiber树
  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;

  // 作为动态的工作单元的属性
  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;

  this.mode = mode;

  this.effectTag = NoEffect;
  this.nextEffect = null;

  this.firstEffect = null;
  this.lastEffect = null;

  // 调度优先级相关
  this.lanes = NoLanes;
  this.childLanes = NoLanes;

  // 指向该fiber在另一次更新时对应的fiber
  this.alternate = null;
}
```
### 作为架构来说
每个Fiber节点有个对应的`React element`，多个Fiber节点是如何连接形成树呢？靠如下三个属性：
```js
// 指向父级Fiber节点
this.return = null;
// 指向子Fiber节点
this.child = null;
// 指向右边第一个兄弟Fiber节点
this.sibling = null;
```
举个例子，如下的组件结构：
```js
function App() {
  return (
    <div>
      i am
      <span>KaSong</span>
    </div>
  )
}
```
对应的`Fiber`树结构：

![](https://react.iamkasong.com/img/fiber.png)

>这里需要提一下，为什么父级指针叫做`return`而不是`parent`或者`father`呢？因为作为一个工作单元，`return`指节点执行完`completeWork`（本章后面会介绍）后会返回的下一个节点。子`Fiber`节点及其兄弟节点完成工作后会返回其父级节点，所以用`return`指代父级节点。


### 作为静态的数据结构
作为一种静态的数据结构，保存了组件相关的信息：
```js
// Fiber对应组件的类型 Function/Class/Host...
this.tag = tag;
// key属性
this.key = key;
// 大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹
this.elementType = null;
// 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName
this.type = null;
// Fiber对应的真实DOM节点
this.stateNode = null;
```
### 作为动态的工作单元
作为动态的工作单元，Fiber中如下参数保存了本次更新相关的信息，我们会在后续的更新流程中使用到具体属性时再详细介绍
```js

// 保存本次更新造成的状态改变相关信息
this.pendingProps = pendingProps;
this.memoizedProps = null;
this.updateQueue = null;
this.memoizedState = null;
this.dependencies = null;

this.mode = mode;

// 保存本次更新会造成的DOM操作
this.effectTag = NoEffect;
this.nextEffect = null;

this.firstEffect = null;
this.lastEffect = null;
```
如下两个字段保存调度优先级相关的信息，会在讲解`Scheduler`时介绍
```js
// 调度优先级相关
this.lanes = NoLanes;
this.childLanes = NoLanes;
```
:::warning:::
注意

在2020年5月，调度优先级策略经历了比较大的重构。以expirationTime属性为代表的优先级模型被lane取代。详见这个PR(opens new window)

如果你的源码中fiber.expirationTime仍存在，请参照调试源码章节获取最新代码。
:::waring:::

## Fiber架构的工作原理
### 什么是“双缓存”
当我们用canvas绘制动画，每一帧绘制前都会调用`ctx.clearRect`清除上一帧的画面。

如果当前帧画面计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。

为了解决这个问题，我们可以在内存中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。

这种在**内存中构建并直接替换的技术**叫做[双缓存](https://baike.baidu.com/item/%E5%8F%8C%E7%BC%93%E5%86%B2) 。

React使用“双缓存”来完成Fiber树的构建与替换——对应着DOM树的创建与更新。

### 双缓存Fiber树
在React中最多会同时存在两棵`Fiber`树。当前屏幕上显示内容对应的`Fiber`树称为`current Fiber`树，正在内存中构建的`Fiber`树称为`workInProgress Fiber`树。

`current Fiber`树中的`Fiber`节点被称为`current fiber`，`workInProgress Fiber`树中的`Fiber节点`被称为`workInProgress fiber`，他们通过`alternate`属性连接。
```js
currentFiber.alternate === workInProgressFiber;
workInProgressFiber.alternate === currentFiber;
```
`React`应用的根节点通过使`current`指针在不同`Fiber`树的`rootFiber`间切换来完成`current Fiber`树指向的切换。

即当`workInProgress Fiber树`构建完成交给`Renderer`渲染在页面上后，应用根节点的current指针指向`workInProgress Fiber`树，此时`workInProgress Fiber树`就变为current Fiber树。

每次状态更新都会产生新的`workInProgress Fiber树`，通过current与workInProgress的替换，完成DOM更新。

### mount时
考虑如下例子：
```js
function App() {
  const [num, add] = useState(0);
  return (
    <p onClick={() => add(num + 1)}>{num}</p>
  )
}

ReactDOM.render(<App/>, document.getElementById('root'));
```
1. 首次执行`ReactDOM.render`会创建`fiberRootNode`（源码中叫fiberRoot）和rootFiber。其中`fiberRootNode`是整个应用的根节点，`rootFiber`是`<App/>`所在组件树的根节点。


>之所以要区分fiberRootNode与rootFiber，是因为在应用中我们可以多次调用`ReactDOM.render`渲染不同的组件树，他们会拥有不同的rootFiber。但是整个应用的根节点只有一个，那就是fiberRootNode。<br/>
>`fiberRootNode`的current会指向当前页面上已渲染内容对应Fiber树，即`current Fiber`树。


2. 接下来进入`render`阶段，根据组件返回的`JSX`在内存中依次创建`Fiber`节点并连接在一起构建Fiber树，被称为`workInProgress Fiber`树。
3. 已构建完的`workInProgress Fiber`树在`commit`阶段渲染到页面。 

### update时
1. 接下来我们点击p节点触发状态改变，这会开启一次新的`render`阶段并构建一棵新的`workInProgress Fiber` 树

>和`mount`时一样，`workInProgress fiber`的创建可以复用`current Fiber`树对应的节点数据。<br/>
>这个决定是否复用的过程就是Diff算法，后面章节会详细讲解
2. `workInProgress Fiber` 树在render阶段完成构建后进入commit阶段渲染到页面上。渲染完毕后，`workInProgress Fiber` 树变为`current Fiber` 树。

