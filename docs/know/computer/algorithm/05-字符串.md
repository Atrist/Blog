## 字符串
3，49，30

## 3. 无重复字符的最长子串
给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

### 题解
没有重复字符的 最长子串，暴力做法，将所有的子串生成出来，然后从其中找到最长的字符串

优化判断逻辑：滑动窗口

判断是否存在重复字符，借助 set，进行判断是否存在 重复字符



## 49. 字母异位词分组
给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

字母异位词 是由重新排列源单词的所有字母得到的一个新单词。

示例
```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]

输入: strs = [""]
输出: [[""]]

输入: strs = ["a"]
输出: [["a"]]
```
### 题解
将相同字符的单词，放置在同一个数组，然后返回

暴力作法： 遍历 + 判断是否为字母异位词

判断是否为字母异位词
1. 方法一，字符串排序后，为字母异位词
   1. 以排序好的字符串为key，排序前的为 value
   2. 最后map 转换成为二维数组
2. 方法二，字符个数标记法，相同标记为字母异位词
   1. 字符个数标记为为key，单词为 value
   2. 最后map 转换成为二维数组


## 30. 串联所有单词的子串
给定一个字符串 s 和一个字符串数组 words。 words 中所有字符串 长度相同。

s 中的 串联子串 是指一个包含  words 中所有字符串以任意顺序排列连接起来的子串。

- 例如，如果 words = ["ab","cd","ef"]， 那么 "abcdef"， "abefcd"，"cdabef"， "cdefab"，"efabcd"， 和 "efcdab" 都是串联子串。 "acdbef" 不是串联子串，因为他不是任何 words 排列的连接。

返回所有串联字串在 s 中的开始索引。你可以以 任意顺序 返回答案。

```
输入：s = "barfoothefoobarman", words = ["foo","bar"]
输出：[0,9]
解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。
子串 "barfoo" 开始位置是 0。它是 words 中以 ["bar","foo"] 顺序排列的连接。
子串 "foobar" 开始位置是 9。它是 words 中以 ["foo","bar"] 顺序排列的连接。
输出顺序无关紧要。返回 [9,0] 也是可以的。
```
### 题解
暴力： 计算出所有的words拼接的字符串，然后在s中判断是否为子串。

优化： 滑动窗口

对 s 进行 words 单词个数的划分，然后左滑一个字符串，然后对单词重新滑入
- 判断是否为子串
- 

为 3. 无重复字符的最长子串 的 进阶版，words 所有字符串 个数相同。

