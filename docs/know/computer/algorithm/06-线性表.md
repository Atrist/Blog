## 线性表：86，16，27，732

## 86. 分隔链表
给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。

你应当 **保留** 两个分区中每个节点的初始相对位置。

### 题解 模拟
使用两个链表small，lager，然后对原有列表进行遍历，大于或者等于x，则放入lager，小于x则放入 small，遍历结束之后，small 和 lager 进行合并。

## 16. 最接近的三数之和
给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。

返回这三个数的和。

假定每组输入只存在恰好一个解。
### 题解 暴力求解
三重循环求出，所有的三元数组，然后求出其中的target的差值。

对三元数组的求法进行优化
1. 对数组进行升序排列
2. 枚举第一个元素a, 剩余的b c两个元素
   1. 因为数组为升序，则
   2. b c 可枚举的范围为 [i+1,n)
   3. 对此枚举过程再次优化
      1. 因数组为升序，可以双指针进行二分查找
      2. 存储此时最小的绝对值



## 27. 移除元素
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

### 题解
双指针，对数组进行遍历操作，首尾遍历，
1. 如果此时 left 小标元素等于val，则将right下标元素复制给此时left，right下标 - 1
2. 遍历到 right 结束


## 732. 我的日程安排表 III
当 k 个日程安排有一些时间上的交叉时（例如 k 个日程安排都在同一时间内），就会产生 k 次预订。

给你一些日程安排 [start, end) ，请你在每个日程安排添加后，返回一个整数 k ，表示所有先前日程安排会产生的最大 k 次预订。

实现一个 MyCalendarThree 类来存放你的日程安排，你可以一直添加新的日程安排。

- MyCalendarThree() 初始化对象。
- int book(int start, int end) 返回一个整数 k ，表示日历中存在的 k 次预订的最大值。

