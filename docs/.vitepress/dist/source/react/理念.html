<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React的理念 | AI</title>
    <meta name="description" content="AI's Blog">
    <link rel="stylesheet" href="/blog/assets/style.3d4e16a3.css">
    <link rel="modulepreload" href="/blog/assets/Home.dd4471c9.js">
    <link rel="modulepreload" href="/blog/assets/app.49b0587d.js">
    <link rel="modulepreload" href="/blog/assets/source_react_理念.md.76418744.lean.js">
    <link rel="modulepreload" href="/blog/assets/app.49b0587d.js">
    <meta name="twitter:title" content="React的理念 | AI">
    <meta property="og:title" content="React的理念 | AI">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-5df6160f><div class="sidebar-button" data-v-5df6160f><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/blog/" aria-label="AI, back to home" data-v-5df6160f data-v-8dbfef3c><!----> AI</a><div class="flex-grow" data-v-5df6160f></div><div class="nav" data-v-5df6160f><nav class="nav-links" data-v-5df6160f data-v-38e3b123><!--[--><div class="item" data-v-38e3b123><div class="nav-link" data-v-38e3b123 data-v-45eb32c6><a class="item" href="/blog/web/" data-v-45eb32c6>web <!----></a></div></div><div class="item" data-v-38e3b123><div class="nav-link" data-v-38e3b123 data-v-45eb32c6><a class="item" href="/blog/leetcode/" data-v-45eb32c6>算法 <!----></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-58e261f2><nav class="nav-links nav" data-v-58e261f2 data-v-38e3b123><!--[--><div class="item" data-v-38e3b123><div class="nav-link" data-v-38e3b123 data-v-45eb32c6><a class="item" href="/blog/web/" data-v-45eb32c6>web <!----></a></div></div><div class="item" data-v-38e3b123><div class="nav-link" data-v-38e3b123 data-v-45eb32c6><a class="item" href="/blog/leetcode/" data-v-45eb32c6>算法 <!----></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-58e261f2><!--[--><li class="sidebar-link"><a class="sidebar-link-item" href="/blog/web/html">HTML</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/blog/web/html/head元素">head元素</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/blog/web/html/基础">基础</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/blog/web/html/body元素/head">head</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/blog/web/html/body元素/文本元素">文本元素</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">CSS</p><!----></li><li class="sidebar-link"><p class="sidebar-link-item">JAVASCRIPT</p><!----></li><li class="sidebar-link"><p class="sidebar-link-item">REACT</p><!----></li><!--]--></ul><!--[--><!--]--></aside><!-- TODO: make this button accessible --><div class="sidebar-mask"></div><main class="page" data-v-d36a7fda><div class="container" data-v-d36a7fda><!--[--><!--]--><div class="content" data-v-d36a7fda><div data-v-d36a7fda><h2 id="react的理念"><a class="header-anchor" href="#react的理念" aria-hidden="true">#</a> React的理念</h2><blockquote><p>我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。</p></blockquote><p>快速响应的瓶颈</p><ul><li>cpu 瓶颈</li><li>IO 瓶颈</li></ul><h3 id="关于-cpu-瓶颈"><a class="header-anchor" href="#关于-cpu-瓶颈" aria-hidden="true">#</a> 关于 cpu 瓶颈:</h3><p>在浏览器每一帧的时间中，预留一些时间给JS线程，React利用这部分时间更新组件（可以看到，在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L119" target="_blank" rel="noopener noreferrer">源码</a> 中，预留的初始时间是5ms）。</p><p>当预留的时间不够用时，<code>React</code> 将线程控制权交还给浏览器使其有时间渲染UI，React则等待下一帧时间到来继续被中断的工作。</p><blockquote><p>这种将长任务分拆到每一帧中，像蚂蚁搬家一样一次执行一小段任务的操作，被称为时间切片（time slice）</p></blockquote><p>解决 CPU 瓶颈的关键是实现 <code>时间切片</code>，而时间切片的关键是：将<strong>同步的更新</strong>变为<strong>可中断的异步更新</strong></p><h3 id="io-瓶颈"><a class="header-anchor" href="#io-瓶颈" aria-hidden="true">#</a> IO 瓶颈</h3><p><code>网络延迟</code> 是前端开发者无法解决的。如何在网络延迟客观存在的情况下，减少用户对网络延迟的感知？</p><p>React给出的答案是 <a href="https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html#putting-research-into-production" target="_blank" rel="noopener noreferrer">将人机交互研究的结果整合到真实的 UI 中</a>。</p><p>关键的一个窍门在于，在本页面停留<strong>短暂的时间</strong>，用于数据的请求，数据回来之后，在跳转到下一个页面。</p><p>当“这一小段时间”足够短时，用户是无感知的。如果请求时间超过一个范围，再显示<code>loading</code>的效果。</p><h3 id="总结"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>这里解决IO和CPU瓶颈问题，落在实处上就是将<strong>同步更新</strong>变成<strong>可中断的异步更新</strong></p><h2 id="react-v15-架构"><a class="header-anchor" href="#react-v15-架构" aria-hidden="true">#</a> React v15 架构</h2><p>两层:</p><ul><li>Reconciler（协调器）—— 负责找出变化的组件</li><li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li></ul><h3 id="reconciler"><a class="header-anchor" href="#reconciler" aria-hidden="true">#</a> Reconciler</h3><p>每当有更新发生时，Reconciler会做如下工作：</p><ul><li>调用函数组件、或class组件的render方法，将返回的JSX转化为虚拟DOM</li><li>将虚拟DOM和上次更新时的虚拟DOM对比</li><li>通过对比找出本次更新中变化的虚拟DOM</li><li>通知Renderer将变化的虚拟DOM渲染到页面上</li></ul><h3 id="renderer（渲染器）"><a class="header-anchor" href="#renderer（渲染器）" aria-hidden="true">#</a> Renderer（渲染器）</h3><p>由于React支持跨平台，所以不同平台有不同的 Renderer。我们前端最熟悉的是负责在浏览器环境渲染的Renderer —— <a href="https://www.npmjs.com/package/react-dom" target="_blank" rel="noopener noreferrer">ReactDOM</a></p><h3 id="架构的缺点"><a class="header-anchor" href="#架构的缺点" aria-hidden="true">#</a> 架构的缺点</h3><p>递归更新， 当组件列表更长，会导致更新时间超过16ms，导致用户交互卡顿。</p><h2 id="react-v16-架构"><a class="header-anchor" href="#react-v16-架构" aria-hidden="true">#</a> React v16 架构</h2><p>三层：</p><ul><li>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler</li><li>Reconciler（协调器）—— 负责找出变化的组件</li><li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li></ul><h3 id="scheduler（调度器）"><a class="header-anchor" href="#scheduler（调度器）" aria-hidden="true">#</a> Scheduler（调度器）</h3><p>既然我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。</p><p>其实部分浏览器已经实现了这个API，这就是requestIdleCallback (opens new window)。但是由于以下因素，React放弃使用：</p><ul><li>浏览器兼容性</li><li>触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的<code>requestIdleCallback</code>触发的频率会变得很低</li></ul><p>基于以上原因，React实现了功能更完备的 <code>requestIdleCallbackc</code> polyfill，这就是<strong>Scheduler</strong>。除了在空闲时触发回调的功能外，Scheduler还提供了多种调度优先级供任务设置。</p><blockquote><p><a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/README.md" target="_blank" rel="noopener noreferrer">Scheduler</a> 是独立于React的库</p></blockquote><h3 id="reconciler（协调器）"><a class="header-anchor" href="#reconciler（协调器）" aria-hidden="true">#</a> Reconciler（协调器）</h3><p>在React15中Reconciler是递归处理虚拟DOM的。让我们看看<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1673" target="_blank" rel="noopener noreferrer">React16的Reconciler</a> 。</p><p>我们可以看见，更新工作从递归变成了可以中断的循环过程。每次循环都会调用<code>shouldYield</code>判断当前是否有剩余时间。</p><div class="language-js"><pre><code><span class="token comment">/** @noinline */</span>
<span class="token keyword">function</span> <span class="token function">workLoopConcurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Perform work until Scheduler asks us to yield</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    workInProgress <span class="token operator">=</span> <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>那么React16是如何解决中断更新时DOM渲染不完全的问题呢？</p><p>在React16中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟DOM打上代表增/删/更新的标记，类似这样：</p><div class="language-js"><pre><code><span class="token keyword">export</span> <span class="token keyword">const</span> Placement <span class="token operator">=</span> <span class="token comment">/*             */</span> <span class="token number">0b0000000000010</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Update <span class="token operator">=</span> <span class="token comment">/*                */</span> <span class="token number">0b0000000000100</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> PlacementAndUpdate <span class="token operator">=</span> <span class="token comment">/*    */</span> <span class="token number">0b0000000000110</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Deletion <span class="token operator">=</span> <span class="token comment">/*              */</span> <span class="token number">0b0000000001000</span><span class="token punctuation">;</span>
</code></pre></div><p>整个Scheduler与Reconciler的工作都在内存中进行。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。</p><h3 id="renderer（渲染器）-1"><a class="header-anchor" href="#renderer（渲染器）-1" aria-hidden="true">#</a> Renderer（渲染器）</h3><p>Renderer根据Reconciler为虚拟DOM打的标记，同步执行对应的DOM操作。</p><p><img src="https://react.iamkasong.com/img/process.png" alt=""></p><p>其中红框中的步骤随时可能由于以下原因被中断：</p><ul><li>有其他更高优任务需要先更新</li><li>当前帧没有剩余时间</li></ul><p>由于红框中的工作都在内存中进行，不会更新页面上的DOM，所以即使反复中断，用户也不会看见更新不完全的DOM（即上一节演示的情况）。</p><blockquote><p>实际上，由于Scheduler和Reconciler都是平台无关的，所以React为他们单独发了一个包<a href="https://www.npmjs.com/package/react-reconciler" target="_blank" rel="noopener noreferrer">react-Reconciler</a>。你可以用这个包自己实现一个ReactDOM</p></blockquote><h3 id="参考资料"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h3><ul><li><a href="https://www.youtube.com/watch?v=CGpMlWVcHok&amp;list=PLPxbbTqCLbGHPxZpw4xj_Wwg8-fdNxJRh&amp;index=7" target="_blank" rel="noopener noreferrer">「英文 外网」Building a Custom React Renderer | React前经理Sophie Alpert</a></li></ul><h2 id="fiber"><a class="header-anchor" href="#fiber" aria-hidden="true">#</a> Fiber</h2><h3 id="什么代数效应"><a class="header-anchor" href="#什么代数效应" aria-hidden="true">#</a> 什么代数效应</h3><p><code>代数效应</code>是<code>函数式编程</code>中的一个概念，用于将<code>副作用</code>从<code>函数</code>调用中分离。</p><h3 id="代数效应在react中的应用"><a class="header-anchor" href="#代数效应在react中的应用" aria-hidden="true">#</a> 代数效应在React中的应用</h3><p>那么代数效应与React有什么关系呢？最明显的例子就是<code>Hooks</code>。</p><p>对于类似useState、useReducer、useRef这样的Hook，我们不需要关注FunctionComponent的state在Hook中是如何保存的，React会为我们处理。</p><p>我们只需要假设useState返回的是我们想要的state，并编写业务逻辑就行。</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> updateNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token parameter">num</span> <span class="token operator">=&gt;</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>num<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>  
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果这个例子还不够明显，可以看看官方的<a href="https://codesandbox.io/s/frosty-hermann-bztrp?file=/src/index.js:152-160" target="_blank" rel="noopener noreferrer">Suspense Demo</a></p><p>在<code>Demo</code>中<code>ProfileDetails</code>用于展示用户名称。而用户名称是<strong>异步请求</strong>的。</p><p>但是<code>Demo</code>中完全是同步的写法。</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">ProfileDetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> user <span class="token operator">=</span> resource<span class="token punctuation">.</span>user<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span>user<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="代数效应与generator"><a class="header-anchor" href="#代数效应与generator" aria-hidden="true">#</a> 代数效应与Generator</h3><p>从React15到React16，协调器（Reconciler）重构的一大目的是：将老的同步更新的架构变为异步可中断更新。</p><p>异步可中断更新可以理解为：更新在执行过程中可能会被打断（浏览器时间分片用尽或有更高优任务插队），当可以继续执行时恢复之前执行的中间状态。</p><p>这就是代数效应中<code>try...handle</code>的作用。</p><p>其实，浏览器原生就支持类似的实现，这就是<code>Generator</code>。</p><p>但是Generator的一些缺陷使React团队放弃了他：</p><ul><li><p>类似async，Generator也是传染性的，使用了Generator则上下文的其他函数也需要作出改变。这样心智负担比较重。</p></li><li><p>Generator执行的中间状态是上下文关联的。</p></li></ul><p>考虑如下例子：</p><div class="language-js"><pre><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token function">doExpensiveWorkA</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> y <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token function">doExpensiveWorkB</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> z <span class="token operator">=</span> y <span class="token operator">+</span> <span class="token function">doExpensiveWorkC</span><span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>每当浏览器有空闲时间都会依次执行其中一个doExpensiveWork，当时间用尽则会中断，当再次恢复时会从中断位置继续执行。</p><p>只考虑“单一优先级任务的中断与继续”情况下Generator可以很好的实现异步可中断更新。</p><p>但是当我们考虑“高优先级任务插队”的情况，如果此时已经完成doExpensiveWorkA与doExpensiveWorkB计算出x与y。</p><p>此时B组件接收到一个高优更新，由于Generator执行的中间状态是上下文关联的，所以计算y时无法复用之前已经计算出的x，需要重新计算。</p><p>如果通过全局变量保存之前执行的中间状态，又会引入新的复杂度。</p><blockquote><p>更详细的解释可以参考这个<a href="https://github.com/facebook/react/issues/7942#issuecomment-254987818" target="_blank" rel="noopener noreferrer">issue</a></p></blockquote><p>基于这些原因，React没有采用Generator实现协调器。</p><h3 id="代数效应与fiber"><a class="header-anchor" href="#代数效应与fiber" aria-hidden="true">#</a> 代数效应与Fiber</h3><p><code>Fiber</code>并不是计算机术语中的新名词，他的中文翻译叫做纤程，与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。</p><p>在很多文章中将纤程理解为协程的一种实现。在JS中，协程的实现便是<code>Generator</code>。</p><p>所以，我们可以将<code>纤程</code>(Fiber)、<code>协程</code>(Generator)理解为代数效应思想在JS中的体现。</p><p>React Fiber可以理解为：</p><p><code>React</code>内部实现的一套状态更新机制。支持任务不同<strong>优先级</strong>，可中断与恢复，并且恢复后可以复用之前的中间状态。</p><p>其中每个任务更新单元为<code>React Element</code>对应的<code>Fiber节点</code>。</p><h3 id="fiber的起源"><a class="header-anchor" href="#fiber的起源" aria-hidden="true">#</a> Fiber的起源</h3><blockquote><p>最早的Fiber官方解释来源于<a href="https://github.com/acdlite/react-fiber-architecture" target="_blank" rel="noopener noreferrer">2016年React团队成员Acdlite的一篇介绍</a></p></blockquote><p>在React15及以前，Reconciler采用递归的方式创建虚拟DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。</p><p>为了解决这个问题，<code>React16</code>将<strong>递归的无法中断的更新</strong>重构为<strong>异步的可中断更新</strong>，由于曾经用于递归的虚拟DOM数据结构已经无法满足需要。于是，全新的Fiber架构应运而生。</p><h3 id="fiber的含义"><a class="header-anchor" href="#fiber的含义" aria-hidden="true">#</a> Fiber的含义</h3><p>Fiber包含三层含义：</p><ol><li>作为架构来说，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为<code>stack Reconciler</code>。React16的Reconciler基于Fiber节点实现，被称为<code>Fiber Reconciler</code>。</li><li>作为静态的数据结构来说，每个Fiber节点对应一个<code>React element</code>，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。</li><li>作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）。</li></ol><h3 id="fiber的结构"><a class="header-anchor" href="#fiber的结构" aria-hidden="true">#</a> Fiber的结构</h3><p>你可以从这里看到<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiber.new.js#L117" target="_blank" rel="noopener noreferrer">Fiber节点的属性定义</a>。虽然属性很多，但我们可以按三层含义将他们分类来看</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">FiberNode</span><span class="token punctuation">(</span>
  <span class="token parameter">tag<span class="token operator">:</span> WorkTag<span class="token punctuation">,</span>
  pendingProps<span class="token operator">:</span> mixed<span class="token punctuation">,</span>
  key<span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> string<span class="token punctuation">,</span>
  mode<span class="token operator">:</span> TypeOfMode<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 作为静态数据结构的属性</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>elementType <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>stateNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 用于连接其他Fiber节点形成Fiber树</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>return <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>ref <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 作为动态的工作单元的属性</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>pendingProps <span class="token operator">=</span> pendingProps<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>memoizedProps <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>dependencies <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>mode <span class="token operator">=</span> mode<span class="token punctuation">;</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>effectTag <span class="token operator">=</span> NoEffect<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>firstEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>lastEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 调度优先级相关</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>lanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>childLanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>

  <span class="token comment">// 指向该fiber在另一次更新时对应的fiber</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>alternate <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="作为架构来说"><a class="header-anchor" href="#作为架构来说" aria-hidden="true">#</a> 作为架构来说</h3><p>每个Fiber节点有个对应的<code>React element</code>，多个Fiber节点是如何连接形成树呢？靠如下三个属性：</p><div class="language-js"><pre><code><span class="token comment">// 指向父级Fiber节点</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>return <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// 指向子Fiber节点</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// 指向右边第一个兄弟Fiber节点</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre></div><p>举个例子，如下的组件结构：</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      i am
      <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>KaSong<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对应的<code>Fiber</code>树结构：</p><p><img src="https://react.iamkasong.com/img/fiber.png" alt=""></p><blockquote><p>这里需要提一下，为什么父级指针叫做<code>return</code>而不是<code>parent</code>或者<code>father</code>呢？因为作为一个工作单元，<code>return</code>指节点执行完<code>completeWork</code>（本章后面会介绍）后会返回的下一个节点。子<code>Fiber</code>节点及其兄弟节点完成工作后会返回其父级节点，所以用<code>return</code>指代父级节点。</p></blockquote><h3 id="作为静态的数据结构"><a class="header-anchor" href="#作为静态的数据结构" aria-hidden="true">#</a> 作为静态的数据结构</h3><p>作为一种静态的数据结构，保存了组件相关的信息：</p><div class="language-js"><pre><code><span class="token comment">// Fiber对应组件的类型 Function/Class/Host...</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag<span class="token punctuation">;</span>
<span class="token comment">// key属性</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
<span class="token comment">// 大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>elementType <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// Fiber对应的真实DOM节点</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>stateNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="作为动态的工作单元"><a class="header-anchor" href="#作为动态的工作单元" aria-hidden="true">#</a> 作为动态的工作单元</h3><p>作为动态的工作单元，Fiber中如下参数保存了本次更新相关的信息，我们会在后续的更新流程中使用到具体属性时再详细介绍</p><div class="language-js"><pre><code>
<span class="token comment">// 保存本次更新造成的状态改变相关信息</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>pendingProps <span class="token operator">=</span> pendingProps<span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>memoizedProps <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>dependencies <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

<span class="token keyword">this</span><span class="token punctuation">.</span>mode <span class="token operator">=</span> mode<span class="token punctuation">;</span>

<span class="token comment">// 保存本次更新会造成的DOM操作</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>effectTag <span class="token operator">=</span> NoEffect<span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

<span class="token keyword">this</span><span class="token punctuation">.</span>firstEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>lastEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre></div><p>如下两个字段保存调度优先级相关的信息，会在讲解<code>Scheduler</code>时介绍</p><div class="language-js"><pre><code><span class="token comment">// 调度优先级相关</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>lanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>childLanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>
</code></pre></div><p>::⚠️:: 注意</p><p>在2020年5月，调度优先级策略经历了比较大的重构。以expirationTime属性为代表的优先级模型被lane取代。详见这个PR(opens new window)</p><p>如果你的源码中fiber.expirationTime仍存在，请参照调试源码章节获取最新代码。 :::waring:::</p><h2 id="fiber架构的工作原理"><a class="header-anchor" href="#fiber架构的工作原理" aria-hidden="true">#</a> Fiber架构的工作原理</h2><h3 id="什么是“双缓存”"><a class="header-anchor" href="#什么是“双缓存”" aria-hidden="true">#</a> 什么是“双缓存”</h3><p>当我们用canvas绘制动画，每一帧绘制前都会调用<code>ctx.clearRect</code>清除上一帧的画面。</p><p>如果当前帧画面计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。</p><p>为了解决这个问题，我们可以在内存中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。</p><p>这种在<strong>内存中构建并直接替换的技术</strong>叫做<a href="https://baike.baidu.com/item/%E5%8F%8C%E7%BC%93%E5%86%B2" target="_blank" rel="noopener noreferrer">双缓存</a> 。</p><p>React使用“双缓存”来完成Fiber树的构建与替换——对应着DOM树的创建与更新。</p><h3 id="双缓存fiber树"><a class="header-anchor" href="#双缓存fiber树" aria-hidden="true">#</a> 双缓存Fiber树</h3><p>在React中最多会同时存在两棵<code>Fiber</code>树。当前屏幕上显示内容对应的<code>Fiber</code>树称为<code>current Fiber</code>树，正在内存中构建的<code>Fiber</code>树称为<code>workInProgress Fiber</code>树。</p><p><code>current Fiber</code>树中的<code>Fiber</code>节点被称为<code>current fiber</code>，<code>workInProgress Fiber</code>树中的<code>Fiber节点</code>被称为<code>workInProgress fiber</code>，他们通过<code>alternate</code>属性连接。</p><div class="language-js"><pre><code>currentFiber<span class="token punctuation">.</span>alternate <span class="token operator">===</span> workInProgressFiber<span class="token punctuation">;</span>
workInProgressFiber<span class="token punctuation">.</span>alternate <span class="token operator">===</span> currentFiber<span class="token punctuation">;</span>
</code></pre></div><p><code>React</code>应用的根节点通过使<code>current</code>指针在不同<code>Fiber</code>树的<code>rootFiber</code>间切换来完成<code>current Fiber</code>树指向的切换。</p><p>即当<code>workInProgress Fiber树</code>构建完成交给<code>Renderer</code>渲染在页面上后，应用根节点的current指针指向<code>workInProgress Fiber</code>树，此时<code>workInProgress Fiber树</code>就变为current Fiber树。</p><p>每次状态更新都会产生新的<code>workInProgress Fiber树</code>，通过current与workInProgress的替换，完成DOM更新。</p><h3 id="mount时"><a class="header-anchor" href="#mount时" aria-hidden="true">#</a> mount时</h3><p>考虑如下例子：</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> add<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>p onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">add</span><span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>num<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App<span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;root&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ol><li>首次执行<code>ReactDOM.render</code>会创建<code>fiberRootNode</code>（源码中叫fiberRoot）和rootFiber。其中<code>fiberRootNode</code>是整个应用的根节点，<code>rootFiber</code>是<code>&lt;App/&gt;</code>所在组件树的根节点。</li></ol><blockquote><p>之所以要区分fiberRootNode与rootFiber，是因为在应用中我们可以多次调用<code>ReactDOM.render</code>渲染不同的组件树，他们会拥有不同的rootFiber。但是整个应用的根节点只有一个，那就是fiberRootNode。<br><code>fiberRootNode</code>的current会指向当前页面上已渲染内容对应Fiber树，即<code>current Fiber</code>树。</p></blockquote><ol start="2"><li>接下来进入<code>render</code>阶段，根据组件返回的<code>JSX</code>在内存中依次创建<code>Fiber</code>节点并连接在一起构建Fiber树，被称为<code>workInProgress Fiber</code>树。</li><li>已构建完的<code>workInProgress Fiber</code>树在<code>commit</code>阶段渲染到页面。</li></ol><h3 id="update时"><a class="header-anchor" href="#update时" aria-hidden="true">#</a> update时</h3><ol><li>接下来我们点击p节点触发状态改变，这会开启一次新的<code>render</code>阶段并构建一棵新的<code>workInProgress Fiber</code> 树</li></ol><blockquote><p>和<code>mount</code>时一样，<code>workInProgress fiber</code>的创建可以复用<code>current Fiber</code>树对应的节点数据。<br> 这个决定是否复用的过程就是Diff算法，后面章节会详细讲解</p></blockquote><ol start="2"><li><code>workInProgress Fiber</code> 树在render阶段完成构建后进入commit阶段渲染到页面上。渲染完毕后，<code>workInProgress Fiber</code> 树变为<code>current Fiber</code> 树。</li></ol></div></div><footer class="page-footer" data-v-d36a7fda data-v-5a019cc9><div class="edit" data-v-5a019cc9><div class="edit-link" data-v-5a019cc9 data-v-3ae295f1><!----></div></div><div class="updated" data-v-5a019cc9><!----></div></footer><!----><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"2a4b4ff7\",\"html_head元素.md\":\"edf164d6\",\"html_基础.md\":\"4066edf3\",\"leetcode_index.md\":\"e95c566e\",\"source_index.md\":\"e0d5c519\",\"web_index.md\":\"bab4a1fb\",\"html_body元素_index.md\":\"086b177a\",\"html_body元素_文本元素.md\":\"7b0c36ed\",\"leetcode_algorithm_index.md\":\"db5f676e\",\"leetcode_algorithm_二叉树的各种遍历.md\":\"03d0fbcb\",\"leetcode_algorithm_位运算.md\":\"7d3b0da3\",\"leetcode_datastructure_index.md\":\"3aaf494d\",\"leetcode_datastructure_二叉树.md\":\"0baba6e0\",\"leetcode_datastructure_栈.md\":\"6531c886\",\"leetcode_datastructure_树.md\":\"e8ebff6e\",\"leetcode_datastructure_链表.md\":\"38ba076b\",\"leetcode_datastructure_队列.md\":\"4883aaa2\",\"leetcode_dayone_1011. 在 d 天内送达包裹的能力.md\":\"ca2dd757\",\"leetcode_dayone_1310. 子数组异或查询.md\":\"02e3505d\",\"leetcode_dayone_137. 只出现一次的数字 ii.md\":\"0ead337e\",\"leetcode_dayone_1473. 粉刷房子 iii.md\":\"b3b46c5e\",\"leetcode_dayone_1482. 制作 m 束花所需的最少天数.md\":\"bce48cc6\",\"leetcode_dayone_1486. 数组异或操作.md\":\"d1e60206\",\"leetcode_dayone_1720. 解码异或后的数组.md\":\"3a4a1031\",\"leetcode_dayone_1723. 完成所有工作的最短时间.md\":\"6dca8a77\",\"leetcode_dayone_1734. 解码异或后的排列.md\":\"2f239e18\",\"leetcode_dayone_403. 青蛙过河.md\":\"d6270e81\",\"leetcode_dayone_554. 砖墙.md\":\"eaff49e1\",\"leetcode_dayone_633. 平方数之和.md\":\"7bbef3fb\",\"leetcode_dayone_690. 员工的重要性.md\":\"7e4f6f35\",\"leetcode_dayone_7. 整数反转.md\":\"435a9059\",\"leetcode_dayone_740. 删除并获得点数.md\":\"46e3ac7f\",\"leetcode_dayone_872. 叶子相似的树.md\":\"23581058\",\"leetcode_dayone_938. 二叉搜索树的范围和.md\":\"c3b14218\",\"leetcode_dayone_index.md\":\"56774e8a\",\"leetcode_offer_03. 数组中重复的数字.md\":\"eee460bd\",\"leetcode_offer_04. 二维数组中的查找.md\":\"ba3d64f7\",\"leetcode_offer_05. 替换空格.md\":\"9fde30d6\",\"leetcode_offer_06. 从尾到头打印链表.md\":\"4e5498fe\",\"leetcode_offer_07. 重建二叉树.md\":\"b487e371\",\"leetcode_offer_09. 用两个栈实现队列.md\":\"de901e97\",\"leetcode_offer_10- i. 斐波那契数列.md\":\"1a6f1e27\",\"leetcode_offer_10- ii. 青蛙跳台阶问题.md\":\"dc6267c6\",\"leetcode_offer_11. 旋转数组的最小数字.md\":\"a3fcb907\",\"leetcode_offer_index.md\":\"cb2d1413\",\"source_react_前置知识.md\":\"33b29236\",\"source_react_理念.md\":\"76418744\",\"web_css_index.md\":\"406c5c96\",\"web_css_动画.md\":\"5e31da39\",\"web_css_布局.md\":\"a4cef480\",\"web_css_选择器.md\":\"e30f137d\",\"web_faq_index.md\":\"cff87bbe\",\"web_html_head元素.md\":\"2d54cead\",\"web_html_index.md\":\"4f3f5a04\",\"web_html_基础.md\":\"aed3158b\",\"web_javascript_index.md\":\"549e81ab\",\"web_react_01.md\":\"d062761d\",\"web_react_02props.md\":\"c9632220\",\"web_react_03state.md\":\"ab9d03fb\",\"web_react_04lifecycle.md\":\"2b8f553d\",\"web_react_05hook.md\":\"d2d49c29\",\"web_react_06redux.md\":\"9976f38d\",\"web_react_index.md\":\"024f4cf3\",\"web_html_body元素_head.md\":\"350edbe6\",\"web_html_body元素_index.md\":\"0dea6571\",\"web_html_body元素_文本元素.md\":\"d90e19af\"}")</script>
    <script type="module" async src="/blog/assets/app.49b0587d.js"></script>
  </body>
</html>