import{o as e,c as d,a}from"./app.06dc3881.js";const r='{"title":"解码异或后的排列","description":"","frontmatter":{},"headers":[{"level":2,"title":"解码异或后的排列","slug":"解码异或后的排列"},{"level":3,"title":"示例 1：","slug":"示例-1："},{"level":3,"title":"示例 2：","slug":"示例-2："},{"level":2,"title":"分析","slug":"分析"}],"relativePath":"leetcode/dayOne/1734. 解码异或后的排列.md","lastUpdated":1620742638308}',n={},c=[a('<h2 id="解码异或后的排列"><a class="header-anchor" href="#解码异或后的排列" aria-hidden="true">#</a> 解码异或后的排列</h2><p>给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 <strong>奇数</strong> 。</p><p>它被加密成另一个长度为 <code>n - 1</code> 的整数数组 encoded ，满足 <code>encoded[i] = perm[i] XOR perm[i + 1]</code> 。比方说，如果 perm = [1,3,2] ，那么 encoded = [2,1] 。</p><p>给你 <code>encoded</code> 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。</p><h3 id="示例-1："><a class="header-anchor" href="#示例-1：" aria-hidden="true">#</a> 示例 1：</h3><div class="language-"><pre><code>输入：encoded = [3,1]\n输出：[1,2,3]\n解释：如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]\n</code></pre></div><h3 id="示例-2："><a class="header-anchor" href="#示例-2：" aria-hidden="true">#</a> 示例 2：</h3><div class="language-"><pre><code>输入：encoded = [6,5,4,6]\n输出：[2,4,1,5,3]\n</code></pre></div><h2 id="分析"><a class="header-anchor" href="#分析" aria-hidden="true">#</a> 分析</h2>',9)];n.render=function(a,r,n,o,l,t){return e(),d("div",null,c)};export{r as __pageData,n as default};
